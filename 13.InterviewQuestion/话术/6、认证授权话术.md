### 1、你给我说一下授权认证（登陆注册）的逻辑

这块来说就比较简单了，我们提供的注册功能有用户名密码注册，手机号注册，微信登陆绑定注册功能

- 用户名密码注册登陆

  我们系统规定的是用户名不得重复，注册的时候，会去做一下重复校验，向后台提交注册信息的时候，密码都会经过md5加密传输，到后台会首先用加密工具生成32位的盐值，然后把用户名通过md5加密之后，用户名的md5和密码的md5和盐值结合之后，生成md5值，然后一起存入数据库，用户登录的时候，按照首先根据用户名去数据库查找用户，找出来用户之后，根据相同的逻辑计算加密之后的密码和数据库的密码对比，对比一致则登陆成功

- 手机号注册登陆（推荐使用，方便快捷）

  这里用到了阿里的短信服务功能，注册的时候，手机号码校验通过之后，向用户手机发送验证码，后台将验证码和手机号对应关系存入redis，用户提交注册之后，验证码跟redis中对比即可

- 微信登陆绑定系统用户注册

  这里结合微信登陆使用的，微信登陆之后，如果发现对应openid没有绑定系统用户，需要提示用户去绑定，然后才能注册

  > 常识：微信开发，有两个平台，
  >
  > 微信开放平台，主要用于app端以及web端扫码登录等开发，app中，微信登陆，微信支付，微信分享等
  >
  > 微信公众平台，主要用于微信网页开发，公众号开发，公众号中网页登陆，微信分享，微信支付等

    - web端微信扫码登录

  微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret。申请微信登录且通过审核后，可开始接入流程。就是你的网站要想实现微信扫码登陆功能首先要在微信备案通过，它才会给你个AppID和AppSecret。

  1、用户点击网站微信登陆图标。

  2、网站带上AppID和回调域名参数请求微信OAuth2.0授权登陆。

  3、第二步通过后，微信返回二维码供用户扫码。

  4、用户扫码确定授权。

  5、微信带上code参数回调java后端回调地址。

  6、java后端获取到code后，在带上带上AppID和AppSecret和code再去调微信接口获取access_token。

  7、获取access_token后就可以解析用户的一些基本信息，比如：微信用户头像、用户名、性别、城市等一些基本参数。


- 微信app登陆

因为是app登陆，需要用到微信开放平台的接入功能，微信登陆采用的auth2.0的验证机制，在开放平台里注册了账号并通过企业认证，获取了AppID 和
AppSecret之后，第一步我们的服务器先获取code，传给移动端，移动端跟微信交互，用户确认授权之后，然后移动端请求我们后台获取用户信息，我们后台会先去用code获取access_token，然后在通过access_token获取用户信息，同时会返回用户的openId，我们会根据这个openId去我们的数据库查，是否已经获取过用户信息，如果获取过用户信息，看一下最后获取时间，因为每3天更新一次，所以这里会看一下是否需要重新获取如果没有获取过用户信息，会通过access_token获取用户信息，提示绑定系统用户，access_token失效时间为2个小时，因为微信有接口请求次数限制，2小时之内不会再去请求微信的access_token

因为我们系统是微服务架构，所以这里使用jwt实现了单点登录，因为平台有很多，有web端、管理端，还有一个清结算平台，实现单点登录会更方便用户使用，登录之后，给用户颁发了一个token令牌，每次请求的时候，都会在请求头里携带这个token，经过我们的网关的时候，会对这个token做一个权限认证，认证通过，然后才能请求到我们的微服务具体的接口

### 2、说一下jwt

微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：

- 服务端不保存任何客户端请求者信息
- 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份，一般这里就是token登陆令牌

这样做的话，会有很多好处，比如

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩
- 减小服务端存储压力

我们项目中也是采用的无状态登陆，使用token作为身份认证的令牌，这个token就是使用jwt生成的，jwt类型的token分为三部分，头部，载荷，签名，头部存储一些识别信息，载荷存储一些用户的基本字段，我们存储的是id的username，签名是通过头部和载荷外加RAS非对称加密生成的

### 3、说一下auth2.0机制

其实就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。

令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是还是有一些差异的。

（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。

（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。

（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。

有了这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。

注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。这也是为什么令牌的有效期，一般都设置得很短的原因。

具体来说，auth2.0一共分成四种授权类型

第一种是授权码模式，这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web
应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。比如A应用想要获取B应用的用户数据，A会首先访问B的授权页面，用户点击确认授权之后，B会请求A配置的回调地址，同时附带上授权码code，A可以通过这个code向B申请登录令牌access_token，获取到登录令牌之后，然后就可以向B应用请求用户信息数据了。最常见的就是微信登陆等第三方登录都用的这种方式。

还有就是隐藏式、密码式、客户端凭证等三种模式，我这边就是大概了解了一下，实际没有使用过。









